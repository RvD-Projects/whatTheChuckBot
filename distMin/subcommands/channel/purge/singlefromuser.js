"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const Subcommand_1=require("../../../structures/Subcommand"),self=new Subcommand_1.SubCommand;async function runFunction(e){const c=e.args,l=e.interaction;e.client;const m=new Subcommand_1.FollowUpObj;try{let n,t,s,e,a=0;const i=c.getUser("author",!0).username,f=c.getChannel("channel",!0);let r=await f.messages.fetch(),o=r.lastKey(),u=[];for(;0<r.size;)a===r.size&&(r=await f.messages.fetch({before:o}),o=r.lastKey(),a=0),r.forEach(e=>{n=e.author.username,a++,t++,s+=n===i?1:0,e.deletable&&n===i&&u.push(e)});for(const d of u)mesgDeleterInterval(d,1e4);s,0===t?m.reply={content:"I was unable to find any messages in this channel?! ðŸ¤”âœ”ï¸"}:0===s?m.reply={content:"No message found from this author! ðŸ¤”âœ”ï¸"}:e!==s&&(m.reply={content:`I was unable to delete ${s-e} of the messages! ðŸ¤”âŒ`},l.client.emit("debug",`CHANNEL ${f.name} IS BEING PURGED BY ${l.member.user.username} => channelID: ${f.id} numDelted: `+e))}catch(e){return m.fromatOnError(e)}return m}async function grandFinal(e,n){for(const t of e)await mesgDeleterInterval(t,n)}async function mesgDeleterInterval(n,t){if(t<=0||t>=Number.MAX_SAFE_INTEGER){const e=new Error;e.message=`[${e.stack}]
Argument msInterval is out of range => number[0-maxSafeInt]`}return new Promise(e=>{console.warn("called interval");setTimeout(async()=>{n.delete(),e(!0)},t)})}self.setRunFunction(runFunction),exports.default=self;